Got it. Here’s a developer-ready spec + code that makes the “jackpot / lottery-style Parlay Button” unambiguous.

⸻

What the button must do (plain English)
	•	Three preset jackpot tiers: $50k, $100k, $1,000,000.
	•	User picks a stake (default $10).
	•	Click “Build for $1M” (or $100k / $50k) → the app auto-constructs a parlay whose projected payout ≥ target using today’s best edges.
	•	The button animates like a slot machine (cycles 10–20 candidate parlays) then locks one in; user can Shuffle to try another or Add to Slip.
	•	Guardrails: leg count range (e.g., 6–12), no duplicate games/markets, exclude injured/scratched, price bounds, max juice caps.

⸻

Payout logic (deterministic)

Projected Payout = stake * Π(decimal_odds_i)

We hit a tier when Projected Payout ≥ target_payout.

⸻

Data you must have per leg

type Leg = {
  id: string;
  gameId: string;
  market: 'H2H' | 'Total' | 'Prop';
  selection: string;  // e.g., "Acuna Jr. o1.5 TB"
  priceDecimal: number; // e.g., 2.05  (American +105)
  edgeScore: number;    // our model advantage, 0–100
  startTime: string;    // ISO
  riskFlags?: string[]; // e.g., ['probable_injury','rain']
};


⸻

Config (single source of truth)

// server/config/parlayJackpot.ts
export const JACKPOT_TIERS = {
  '50k':  50_000,
  '100k': 100_000,
  '1M':   1_000_000,
} as const;

export const PARLAY_CONSTRAINTS = {
  minLegs: 6,
  maxLegs: 12,
  minOdds: 1.3,   // don’t allow micro-odds
  maxOdds: 3.5,   // avoid wild longshots
  minEdge: 55,    // only use edges our model likes
  maxPerTeam: 1,  // no stacking same team/market
};


⸻

Backend: build candidate parlays that hit the tier

// server/services/jackpotBuilder.ts
import { JACKPOT_TIERS, PARLAY_CONSTRAINTS } from '../config/parlayJackpot';

type BuildInput = {
  tier: keyof typeof JACKPOT_TIERS;   // '50k' | '100k' | '1M'
  stake: number;                      // e.g., 10, 25, 100
  legs: Leg[];                        // prefiltered (today only, not started)
  maxCandidates?: number;             // default 20
};

type Candidate = {
  legIds: string[];
  payout: number;
  decimalProduct: number;
  estHitProb: number;   // (optional) product of modeled hit probs
};

export function buildJackpotCandidates({
  tier, stake, legs, maxCandidates = 20,
}: BuildInput): Candidate[] {
  const T = JACKPOT_TIERS[tier];
  const C = PARLAY_CONSTRAINTS;

  // 1) filter for quality + valid odds
  const pool = legs
    .filter(L => L.priceDecimal >= C.minOdds && L.priceDecimal <= C.maxOdds)
    .filter(L => (L.edgeScore ?? 0) >= C.minEdge)
    .sort((a,b) => (b.edgeScore - a.edgeScore) || (b.priceDecimal - a.priceDecimal));

  const out: Candidate[] = [];
  const usedKeys = new Set<string>();

  // 2) greedy + random mix to assemble many candidate combos
  for (let attempt = 0; attempt < 2000 && out.length < maxCandidates; attempt++) {
    const pickCount = randInt(C.minLegs, C.maxLegs);
    const chosen: Leg[] = [];
    const usedGames = new Set<string>();

    // seed with top edges, then diversify randomly
    const seed = Math.min(3, pickCount);
    for (let i = 0; i < seed; i++) {
      const L = pool[i];
      if (L && !usedGames.has(L.gameId)) {
        chosen.push(L); usedGames.add(L.gameId);
      }
    }
    // fill remaining with random high-edge legs respecting constraints
    let safety = 0;
    while (chosen.length < pickCount && safety++ < 2000) {
      const idx = Math.floor(Math.random() * Math.min(pool.length, 200));
      const L = pool[idx];
      if (!L) continue;
      if (usedGames.has(L.gameId)) continue;
      chosen.push(L); usedGames.add(L.gameId);
    }

    if (chosen.length < C.minLegs) continue;

    const decimalProduct = chosen.reduce((p, l) => p * l.priceDecimal, 1);
    const payout = stake * decimalProduct;
    if (payout < T) continue;

    // de-dupe by sorted leg ids
    const key = chosen.map(l => l.id).sort().join('|');
    if (usedKeys.has(key)) continue;
    usedKeys.add(key);

    out.push({
      legIds: chosen.map(l => l.id),
      payout: Math.round(payout * 100) / 100,
      decimalProduct,
      estHitProb: estimateParlayProb(chosen), // optional
    });
  }

  // 3) sort: highest est EV first (or highest edge density)
  return out.sort((a,b) => (b.estHitProb * b.payout) - (a.estHitProb * a.payout));
}

function estimateParlayProb(legs: Leg[]): number {
  // if you store modeled leg probs on the Leg, use them; else quick proxy from edgeScore
  const toProb = (edgeScore: number) => Math.min(0.8, 0.5 + (edgeScore - 50) * 0.01);
  return legs.reduce((p, l) => p * toProb(l.edgeScore ?? 50), 1);
}

function randInt(a:number,b:number){ return a + Math.floor(Math.random()*(b-a+1)); }

API endpoint

// server/routes/parlay.ts
app.get('/api/jackpot-candidates', async (req, res) => {
  const tier = (req.query.tier as string) ?? '1M';
  const stake = Number(req.query.stake ?? 10);

  const todayLegs = await getEligibleLegsForToday(); // join data provider + our model
  const candidates = buildJackpotCandidates({ tier: tier as any, stake, legs: todayLegs });

  return res.json({ tier, stake, candidates });
});


⸻

Frontend: the flashing “slot machine” button

// client/src/components/JackpotButton.tsx
import React, { useEffect, useRef, useState } from 'react';

type Candidate = { legIds: string[]; payout: number; decimalProduct: number; estHitProb: number; };

export default function JackpotButton({
  tier = '1M',
  stake = 10,
  onLockIn,
}: { tier: '50k'|'100k'|'1M'; stake: number; onLockIn: (c: Candidate)=>void }) {
  const [candidates, setCandidates] = useState<Candidate[]>([]);
  const [current, setCurrent] = useState<Candidate | null>(null);
  const [spinning, setSpinning] = useState(false);
  const timer = useRef<number | null>(null);

  async function fetchCandidates() {
    const r = await fetch(`/api/jackpot-candidates?tier=${tier}&stake=${stake}`);
    const j = await r.json();
    setCandidates(j.candidates ?? []);
  }

  useEffect(() => { fetchCandidates(); }, [tier, stake]);

  function startSpin() {
    if (!candidates.length) return;
    setSpinning(true);
    let i = 0, ticks = 0, duration = 1800; // 1.8s spin
    const interval = 80;
    timer.current = window.setInterval(() => {
      setCurrent(candidates[i % candidates.length]);
      i++; ticks += interval;
      if (ticks >= duration) {
        stopSpin();
      }
    }, interval);
  }

  function stopSpin() {
    if (timer.current) window.clearInterval(timer.current);
    setSpinning(false);
    // lock the last shown candidate
    if (current) onLockIn(current);
  }

  return (
    <div className="flex flex-col gap-2">
      <button
        className="px-4 py-3 rounded-xl bg-indigo-600 text-white w-full"
        onClick={startSpin}
        disabled={spinning}
      >
        {spinning ? 'Finding your $' + tier + ' parlay…' : `Build for $${tier}`}
      </button>

      {current && (
        <div className="p-3 rounded-lg border">
          <div className="text-sm text-gray-500">Projected Payout</div>
          <div className="text-xl font-bold">${current.payout.toLocaleString()}</div>
          <div className="text-xs text-gray-500">EV proxy: {(current.estHitProb * current.payout).toFixed(2)}</div>
          <div className="flex gap-2">
            <button className="btn" onClick={startSpin}>Shuffle</button>
            <button className="btn btn-primary" onClick={()=>onLockIn(current!)}>Add to Slip</button>
          </div>
        </div>
      )}
    </div>
  );
}

Render selected candidate to a bet slip

// client/src/components/BetSlip.tsx (sketch)
function addCandidateToSlip(c: Candidate, legLookup: Record<string, Leg>) {
  const legs = c.legIds.map(id => legLookup[id]);
  // add to global slip store
}


⸻

Guardrails the dev must enforce
	1.	Constraints from PARLAY_CONSTRAINTS.
	2.	Data source must be real-time and verified (no “Alexander Bogers” fake names). If you’re using TheSportsDB, replace with a paid MLB provider (Sportradar, The Odds API, Covers, FantasyData, or official MLB Stats API for players + weather API for conditions).
	3.	Exclusions: remove legs with riskFlags, weather postponements, or “probable” injury tags.
	4.	No duplicate markets in same parlay (e.g., two hitter props for the same player/game if you don’t allow it).
	5.	Explain jackpot math in UI tooltip: “We auto-pick edges until projected payout ≥ target for your stake. You can shuffle or edit legs.”

⸻

One-line requirement to your dev

“Implement a Jackpot Parlay Builder with fixed tiers ($50k, $100k, $1M). Given a stake, the builder must auto-assemble 20 candidates from our top-edge legs so that stake × product(decimal_odds) ≥ tier. Show a 1.8s slot-machine animation cycling through candidates, then lock one with Shuffle/Add to Slip. Enforce constraints (6–12 legs, odds bounds, min edge, no duplicate games/markets, exclude risk flags). Provide /api/jackpot-candidates returning candidates and use the React component above.”

If you want, I’ll also add the SQL tables and a unit test for buildJackpotCandidates.